#!/bin/bash


#This program is use to install/configure/test TVK product with one click and few required inputs



#This module is used to perform preflight check which checks if all the pre-requisites are satisfied before installing Triliovault for Kubernetes application in a Kubernetes cluster

preflight_checks()
{
  ret=$(kubectl krew 2>/dev/null)
  if [[ -z "$ret" ]];then
    echo "Please install krew plugin and then try.For information on krew installation please visit:"
    echo "https://krew.sigs.k8s.io/docs/user-guide/setup/install/"
    exit 1
  fi
  if  [[ $(kubectl tvk-preflight --help  2>/dev/null) ]];
  then
    echo "Skipping plugin tvk-preflight installation as it is already installed"
  else
    plugin_url='https://github.com/trilioData/tvk-plugins.git'
    kubectl krew index add tvk-plugins "$plugin_url" >/dev/null 2>/dev/null
    kubectl krew install tvk-plugins/tvk-preflight >/dev/null  1>/dev/null
  fi 
  if  [[ -z "${input_config}" ]];then
    read -r -p "Provide storageclass to be used for TVK/Application Installation(storageclass with default annotation): " storage_class
  fi
  #read -p "Provide storageclass to be used for TVK/Application Installation(storageclass with default annotation): " storage_class
  if [[ -z "$storage_class" ]];then
	  storage_class=$(kubectl get storageclass | grep -w '(default)' | awk  '{print $1}')
  fi
  check=$(kubectl tvk-preflight --storageclass "$storage_class" | tee /dev/tty)
  check_for_fail=$(echo "$check" | grep  'Some Pre-flight Checks Failed!')
  if [[ -z "$check_for_fail" ]];then
    echo "All preflight checks are done and you can proceed"
  else 
    if  [[ -z "${input_config}" ]];then
      echo "There are some failures"
      read -r -p "Do you want to proceed?y/n: " proceed_even_PREFLIGHT_fail
    fi
    if [[ "$proceed_even_PREFLIGHT_fail" != "Y" ]] && [[ "$proceed_even_PREFLIGHT_fail" != "y" ]];then
      exit 1
    fi
  fi

}


#function to print waiting symbol
wait_install()
{
  #set -x
  runtime=$1
  spin='-\|/'
  i=0
  endtime=$(date -ud "$runtime" +%s)
  val1=$(eval "$2")
  while [[ $(date -u +%s) -le $endtime ]] && [[ "" == "$val1" ]] || [[ "$val1" == '{}' ]]
  do
    i=$(( (i+1) %4 ))
    printf "\r %s" "${spin:$i:1}"
    sleep .1
    val1=$(eval "$2")
  done
  echo ""
}

#This module is used to install TVK along with its free trial license
install_tvk()
{
  #Install helm3
  curl -s https://get.helm.sh/helm-v3.4.0-linux-amd64.tar.gz | tar xz 2>/dev/null
  ./linux-amd64/helm version >/dev/null 2>/dev/null
  cp linux-amd64/helm /usr/local/bin/ 2>/dev/null

  # Add helm repo and install triliovault-operator chart
  helm repo add triliovault-operator http://charts.k8strilio.net/trilio-stable/k8s-triliovault-operator >/dev/null 2>/dev/null
  helm repo add triliovault http://charts.k8strilio.net/trilio-stable/k8s-triliovault >/dev/null 2>/dev/null
  helm repo update >/dev/null 2>/dev/null
  if  [[ -z ${input_config} ]];then
    read -r -p "Please provide the operator version to be installed(2.1.0): " operator_version
    read  -r -p "Please provide the triliovault manager version(v2.1.1-alpha): " triliovault_manager_version
    read  -r -p "if resource exist, still user wants to proceed: " if_resource_exists_still_proceed
  fi
  if [[ -z "$operator_version" ]];then
    operator_version='2.1.0'
  fi
  if [[ -z "$triliovault_manager_version" ]];then
    triliovault_manager_version='v2.1.1-alpha'
  fi
  #check if TVK operator already exists
  if [[ $(kubectl get pods -l release=triliovault-operator 2>/dev/null) ]];then  
    echo "TVK operator already exists"
    if ! [[ $if_resource_exists_still_proceed ]];then
  	exit 1
    fi
  else
    # Install triliovault operator
    echo "Installing Triliovault operator..."
    helm install triliovault-operator triliovault-operator/k8s-triliovault-operator --version $operator_version 2>/dev/null
    cmd="kubectl get pods -l release=triliovault-operator 2>/dev/null | grep Running"
    wait_install "10 minute" "$cmd"
    if ! kubectl get pods -l release=triliovault-operator 2>/dev/null | grep -q Running;then
      echo "TVO installation failed"
      exit 1
    fi
    echo "Triliovault operator is installed"
  fi
  #check if TVK manager is installed
  if [[ $(kubectl get pods -l app=k8s-triliovault-control-plane 2>/dev/null) ]] && [[ $(kubectl get pods -l app=k8s-triliovault-admission-webhook 2>/dev/null) ]];then
    echo "TVK Manager is already exists"
    echo "Checking if TVK manager is of required version.."
    tvm=$(kubectl get TrilioVaultManager -o json | grep releaseVersion | awk '{print$2}')
    tvm=$(sed -e 's/^"//' -e 's/"$//' <<<"$tvm")
    if [[ $tvm == "$triliovault_manager_version" ]];then
      echo "Triliovault manager/application of required version is already installed"
      return
    fi
    if ! [[ $if_resource_exists_still_proceed ]];then
        exit 1
    fi
  fi
    
  # Create TrilioVaultManager CR
  yq eval -i '.spec.trilioVaultAppVersion="'$triliovault_manager_version'" | .spec.trilioVaultAppVersion style="double"' TVM.yaml 2>/dev/null
  kubectl apply -f TVM.yaml >/dev/null 2>/dev/null
  sleep 2
  echo "Installing Triliovault manager...."
  cmd="kubectl get pods -l app=k8s-triliovault-control-plane 2>/dev/null | grep Running"
  wait_install "10 minute" "$cmd"
  cmd="kubectl get pods -l app=k8s-triliovault-admission-webhook 2>/dev/null | grep Running"
  wait_install "10 minute" "$cmd"
  if ! kubectl get pods -l app=k8s-triliovault-control-plane 2>/dev/null | grep -q Running && ! kubectl get pods -l app=k8s-triliovault-admission-webhook 2>/dev/null | grep -q Running; then
      echo "TVM installation failed"
      exit 1
  fi
  echo "TVK Manager is installed"
  install_license
}


#This module is use to install license
install_license(){
  echo "Installing Freetrial license..."
  #Install required packages
  sudo apt update >/dev/null 2>/dev/null
  yes | sudo apt install python3-pip >/dev/null 2>/dev/null
  pip3 install beautifulsoup4 >/dev/null 2>/dev/null
  pip3 install lxml >/dev/null 2>/dev/null

  #install trilio license
  python3 install_license.py

}


#This module is used to configure TVK UI
configure_ui()
{
 if  [[ -z ${input_config} ]];then
   echo -e "TVK UI can be accessed using \n1.Loadbalancer \n2.Nodeport \n3.PortForwarding"
   read -r -p "Please enter option: " ui_access_type
 else
   if [[ $ui_access_type == 'Loadbalancer' ]];then
     ui_access_type=1
   elif [[ $ui_access_type == 'Nodeport' ]];then
     ui_access_type=2
   elif [[ $ui_access_type == 'PortForwarding' ]];then
     ui_access_type=3
   else
     echo "Wrong option selected for ui_access_type"
     exit 1
   fi
 fi
 if [[ -z "$ui_access_type" ]]; then
      ui_access_type=2
 fi
 case $ui_access_type in
   3)
     echo "kubectl port-forward --address 0.0.0.0 svc/k8s-triliovault-ingress-gateway 80:80 &"
     echo "The above command will start forwarding TVK management console traffic to the localhost IP of 127.0.0.1 via port 80"
     ;;
   2)
     configure_nodeport_for_tvkui
     ;;
   1)
     configure_loadbalancer_for_tvkUI
     ;;
   *)
     echo "Incorrect choice"
     exit 1
     ;;
   esac
   shift

}

#This function is used to configure TVK UI through nodeport
configure_nodeport_for_tvkui()
{
  if  [[ -z ${input_config} ]];then
    read -r -p "Please enter hostname for a cluster: " tvkhost_name
  fi
  gateway=$(kubectl get pods --no-headers=true | awk '/k8s-triliovault-ingress-gateway/{print $1}')
  node=$(kubectl get pods "$gateway" -o jsonpath='{.spec.nodeName}')
  ip=$(kubectl get node "$node"  -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}')
  port=$(kubectl get svc k8s-triliovault-ingress-gateway  -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
  kubectl patch ingress k8s-triliovault-ingress-master -p '{"spec":{"rules":[{"host":"'"${tvkhost_name}-tvk.com"'"}]}}'
  echo "For accesing UI, create an entry in /etc/hosts file for the IPs like '$ip  $tvkhost_name-tvk.com'"
  echo "After creating an entry,TVK UI can be accessed through http://$tvkhost_name-tvk.com:$port"
  echo "For https access, please refer - https://docs.trilio.io/kubernetes/management-console/user-interface/accessing-the-ui" 
}

#This function is used to configure TVK UI through Loadbalancer
configure_loadbalancer_for_tvkUI()
{
 if  [[ -z ${input_config} ]];then
   read -r -p "Please enter domainname for cluster: " domain
   read -r -p "Please enter host name  for a cluster: " tvkhost_name
   read -r -p "Please enter cluster name: " cluster_name 
 fi
 kubectl patch svc k8s-triliovault-ingress-gateway -p '{"spec": {"type": "LoadBalancer"}}' >/dev/null 2>/dev/null
 echo "Configuring UI......This may take some time"
 cmd="kubectl get svc k8s-triliovault-ingress-gateway -o 'jsonpath={.status.loadBalancer}'"
 wait_install "20 minute" "$cmd"
 val_status=$(kubectl get svc k8s-triliovault-ingress-gateway -o 'jsonpath={.status.loadBalancer}')
 if [[ $val_status == '{}' ]]
 then
    echo "Loadbalancer taking time to get External IP"
    exit 1
 fi
 external_ip=$(kubectl get svc k8s-triliovault-ingress-gateway -o 'jsonpath={.status.loadBalancer.ingress[0].ip}')
 kubectl patch ingress k8s-triliovault-ingress-master -p '{"spec":{"rules":[{"host":"'"${tvkhost_name}.${domain}"'"}]}}' >/dev/null 2>/dev/null
 doctl compute domain records create "${domain}" --record-type A --record-name "${tvkhost_name}" --record-data "${external_ip}" >/dev/null 2>/dev/null
 doctl kubernetes cluster kubeconfig show "${cluster_name}" > config_"${cluster_name}" 
 link="http://${tvkhost_name}.${domain}/login"
 echo "You can access TVK UI: $link"
 echo "provide config file stored at location: $PWD/config_${cluster_name}"
 echo "Info:UI may take 30 min to come up"
}



#This module is used to create target to be used for TVK backup and restore
create_target()
{
   if  [[ -z ${input_config} ]];then
     echo -e "Target can be created on NFS or s3 compatible storage\n1.NFS(default) \n2.DOKs_S3"
     read -r -p "select option: " target_type
   else
     if [[ $target_type == 'NFS' ]];then
       target_type=1
     elif [[ $target_type == 'DOKs_S3' ]];then
       target_type=2
     else
       echo "Wrong value provided for target"
     fi
   fi
   if [[ -z "$target_type" ]]; then
      target_type=2
   fi
   case $target_type in
     2)
        yes | sudo apt-get install s3cmd >/dev/null 2>/dev/null
	if  [[ -z ${input_config} ]];then
          echo "for creation of bucket, please provide input"
          read -r -p "Access_key: " access_key
          read -r -p "Secret_key: " secret_key
          read -r -p "Host Base(nyc3.digitaloceanspaces.com): " host_base
	  read -r -p "Host Bucket(%(bucket)s.nyc3.digitaloceanspaces.com): " host_bucket
	  read -r -p "gpg_passphrase(trilio): " gpg_passphrase
          read -r -p "Bucket Name: " bucket_name
          read -r -p "Target Name: " target_name
          read -r -p "Target Namespace: " target_namespace
	  read -r -p "thresholdCapacity(1000Gi): " thresholdCapacity
	  read -r -p "if resource exist, still user wants to proceed: " if_resource_exists_still_proceed
        fi
	if [[ $(kubectl get target "$target_name" -n "$target_namespace" 2>/dev/null) ]];
        then
	  echo "Target with same name already exists"
	  if ! [[ $if_resource_exists_still_proceed ]]
	  then
	    exit 1
	  else
	    return
          fi
	fi
	if [[ -z "$gpg_passphrase" ]];then
	  gpg_passphrase="trilio"
	fi
	if [[ -z "$thresholdCapacity" ]];then
	  thresholdCapacity='1000Gi'
	fi
        if [[ -z "$host_base" ]]; then
          host_base="nyc3.digitaloceanspaces.com"
        fi
        if [[ -z "$host_bucket" ]]; then
          host_bucket="%(bucket)s.nyc3.digitaloceanspaces.com"
        fi
        region="$( cut -d '.' -f 1 <<< "$host_base" )"
        for i in access_key secret_key host_base host_bucket gpg_passphrase 
        do
          sed -i "s/^\($i\s*=\s*\).*$/\1${!i}/" s3cfg_config
          sudo cp s3cfg_config "$HOME"/.s3cfg 
        done
        #create bucket
	ret_val=$(s3cmd mb s3://"$bucket_name"  2>&1)
        ret_code=$(echo "$ret_val" | grep 'Bucket already exists')
	if [[ "$ret_code" ]]; then 
          echo "WARNING: Bucket already exists"
	else
	  echo "$ret_val"
        fi
        #create S3 target
        url="https://$host_base"
        yq eval -i '.metadata.name="'"$target_name"'"' target.yaml 2>/dev/null
        yq eval -i '.metadata.namespace="'"$target_namespace"'"' target.yaml 2>/dev/null
        #yq write --inplace target.yaml metadata.name $name
        #yq write --inplace target.yaml metadata.namespace $namespace
        yq eval -i '.spec.objectStoreCredentials.url="'$url'" | .spec.objectStoreCredentials.url style="double"' target.yaml 2>/dev/null
        yq eval -i '.spec.objectStoreCredentials.accessKey="'"$access_key"'" | .spec.objectStoreCredentials.accessKey style="double"' target.yaml 2>/dev/null
        yq eval -i '.spec.objectStoreCredentials.secretKey="'"$secret_key"'" | .spec.objectStoreCredentials.secretKey style="double"' target.yaml 2>/dev/null
        yq eval -i '.spec.objectStoreCredentials.bucketName="'"$bucket_name"'" | .spec.objectStoreCredentials.bucketName style="double"' target.yaml 2>/dev/null
        yq eval -i '.spec.objectStoreCredentials.region="'"$region"'" | .spec.objectStoreCredentials.region style="double"' target.yaml 2>/dev/null
	yq eval -i '.spec.thresholdCapacity="'"$thresholdCapacity"'"' target.yaml 2>/dev/null
        if ! kubectl apply -f target.yaml;then
	  echo "Traget creation failed"
	  exit 1
        fi
	;;
     1)
	if  [[ -z ${input_config} ]];then
          read -r -p "Target Name: " target_name
          read -r -p "NFSserver: " nfs_server
          read -r -p "namespace: " target_namespace
          read -r -p "Export Path: " nfs_path
          read -r -p "NFSoption(nfsvers=4): " nfs_options
          read -r -p "thresholdCapacity(100Gi): " thresholdCapacity
	  read -r -p "if resource exist, still user wants to proceed: " if_resource_exists_still_proceed
	fi
	if [[ $(kubectl get target "$target_name" -n "$target_namespace" 2>/dev/null) ]];
        then
          echo "Target with same name already exists"
          if ! [[ $if_resource_exists_still_proceed ]]
          then
            exit 1
          else
            return
          fi
        fi
	if [[ -z "$thresholdCapacity" ]];then
          thresholdCapacity='1000Gi'
        fi
        if [[ -z "$nfs_options" ]]; then
          nfs_options='nfsvers=4'
        fi
        yq eval -i '.metadata.name="'"$target_name"'"' nfs_target.yaml 2>/dev/null
        yq eval -i '.metadata.namespace="'"$target_namespace"'"' nfs_target.yaml 2>/dev/null
        yq eval -i '.spec.nfsCredentials.nfsExport="'"$nfs_server":"$nfs_path"'"' nfs_target.yaml 2>/dev/null
        yq eval -i '.spec.nfsCredentials.nfsOptions="'"$nfs_options"'"' nfs_target.yaml 2>/dev/null
        yq eval -i '.spec.thresholdCapacity="'"$thresholdCapacity"'"' nfs_target.yaml 2>/dev/null
        if ! kubectl apply -f nfs_target.yaml;then
	  echo "Target creation failed"
	  exit 1
	fi
	;;
    *)
	echo "Wrong selection"
	exit 1
	;;
    esac
    shift
   echo "Creating target..."
   cmd="kubectl get target $target_name -n  $target_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -e Available -e Unavailable"
   wait_install "20 minute" "$cmd"
   if ! kubectl get target "$target_name"  -n  "$target_namespace" -o 'jsonpath={.status.status}' 2>/dev/null | grep -q Available; then
     echo "Failed to create target"
     exit 1
   else
     echo "Target is Available to use"
   fi

}


#This module is used to test TVK backup and restore for user.
sample_test()
{
   if  [[ -z ${input_config} ]];then
     echo "Please provide input for test demo"
     read -r -p "Target Name: " target_name
     read -r -p "Target Namespace: "  target_namespace
     read -r -p "Backupplan name(trilio-test-backup): " bk_plan_name
     read -r -p "Backup Name(trilio-test-backup): " backup_name
     read -r -p "Backup Namespace Name(trilio-test-backup): " backup_namespace
     read -r -p "if resource exist, still user wants to proceed: " if_resource_exists_still_proceed
   fi
   if [[ -z "$backup_namespace" ]]; then
      backup_namespace=trilio-test-backup
   fi
   if [[ -z "$backup_name" ]]; then
      backup_name="trilio-test-backup"
   fi
   if [[ -z "$bk_plan_name" ]]; then
      bk_plan_name="trilio-test-backup"
   fi
   res=$(kubectl get ns $backup_namespace 2>/dev/null)
   if [[ -z "$res" ]]; then
     kubectl create ns $backup_namespace 2>/dev/null
   fi
   #Add stable helm repo
   helm repo add stable https://charts.helm.sh/stable >/dev/null 2>/dev/null
   helm repo update >/dev/null 2>/dev/null
   echo "User can take backup in multiple ways"
   if  [[ -z ${input_config} ]];then
     echo -e "Select an the backup way\n1.Label based(MySQL)\n2.Namespace based(Wordpress)\n3.Operator based(Postgres Operator)\n4.Helm based(Mongodb)"
     read -r -p "Select option: " backup_way
   else
     if [[ $backup_way == "Label_based" ]];then
       backup_way=1
     elif [[ $backup_way == "Namespace_based" ]];then
       backup_way=2
     elif [[ $backup_way == "Operator_based" ]];then
       backup_way=3
     elif [[ $backup_way == "Helm_based" ]];then
       backup_way=4
     else
       echo "Backup way is wrong/not defined"
       exit 1
     fi
   fi
   case $backup_way in
      1)
        ## Install mysql helm chart
	#check if app is already installed with same name
        if helm list -n "$backup_namespace" | grep -w -q mysql-qa;
        then
          echo "Application exists"
          if ! [[ $if_resource_exists_still_proceed ]]
          then
            exit 1
	  fi
        else
          helm install mysql-qa stable/mysql -n $backup_namespace
          echo "Installing Application"
          cmd="kubectl get pods -l app=mysql-qa -n $backup_namespace 2>/dev/null | grep Running"
          wait_install "10 minute" "$cmd"
          if ! kubectl get pods -l app=mysql-qa -n $backup_namespace 2>/dev/null | grep -q Running; then
            echo "Application installation failed"
            exit 1
          fi
          yq eval -i 'del(.spec.backupPlanComponents)' backupplan.yaml 2>/dev/null
          yq eval -i '.spec.backupPlanComponents.custom[0].matchLabels.app="mysql-qa"' backupplan.yaml 2>/dev/null
        fi
	;;
      2)
	if helm list -n $backup_namespace | grep -w -q my-wordpress;
	then
	  echo "Application exists"
	  if ! [[ $if_resource_exists_still_proceed ]]
          then
            exit 1
          fi
	else
	  #Add bitnami helm repo
	  helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>/dev/null
          helm install my-wordpress bitnami/wordpress -n $backup_namespace >/dev/null 2>/dev/null
	  echo "Installing Application"
	  runtime="10 minute"
          spin='-\|/'
          i=0
          endtime=$(date -ud "$runtime" +%s)
	  while [[ $(date -u +%s) -le $endtime ]] && kubectl get pod -l  app.kubernetes.io/instance=my-wordpress -n $backup_namespace -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False
          do
            i=$(( (i+1) %4 ))
            printf "\r %s" "${spin:$i:1}"
            sleep .1
          done 
	  if kubectl get pod -l  app.kubernetes.io/instance=my-wordpress -n $backup_namespace -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False;then
            echo "Wordpress installation failed"
	    exit 1
	  fi
	  yq eval -i 'del(.spec.backupPlanComponents)' backupplan.yaml 2>/dev/null
	fi
	;;

      3)
        sed -i "/^\([[:space:]]*namespace: \).*/s//\1$backup_namespace/" postgres-operator/manifests/configmap.yaml
        sed -i "/^\([[:space:]]*namespace: \).*/s//\1$backup_namespace/" postgres-operator/manifests/operator-service-account-rbac.yaml
        sed -i "/^\([[:space:]]*namespace: \).*/s//\1$backup_namespace/" postgres-operator/manifests/postgres-operator.yaml
        sed -i "/^\([[:space:]]*namespace: \).*/s//\1$backup_namespace/" postgres-operator/manifests/api-service.yaml	
	kubectl create -f postgres-operator/manifests/configmap.yaml -n $backup_namespace # configuration
        kubectl create -f postgres-operator/manifests/operator-service-account-rbac.yaml -n $backup_namespace # identity and permissions
        kubectl create -f postgres-operator/manifests/postgres-operator.yaml  -n $backup_namespace # deployment
        kubectl create -f postgres-operator/manifests/api-service.yaml  -n $backup_namespace # operator API to be used by UI
	#check if operator is up and running
	echo "Installing Postgres pperator..."
	runtime="10 minute"
        spin='-\|/'
        i=0
        endtime=$(date -ud "$runtime" +%s)
	while [[ $(date -u +%s) -le $endtime ]] && kubectl get pod -l name=postgres-operator -n $backup_namespace  -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False
        do
          i=$(( (i+1) %4 ))
          printf "\r %s" "${spin:$i:1}"
          sleep .1
        done
	if kubectl get pod -l name=postgres-operator -n $backup_namespace  -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False;then
          echo "Postgress operator installation failed"
          exit 1
        fi
	#Deploy the operator UI
	#Create a Postgres cluster
	sed -i "/^\([[:space:]]*namespace: \).*/s//\1$backup_namespace/" postgres-operator/manifests/minimal-postgres-manifest.yaml
        kubectl create -f postgres-operator/manifests/minimal-postgres-manifest.yaml -n $backup_namespace
	runtime="15 minute"
        spin='-\|/'
        i=0
        endtime=$(date -ud "$runtime" +%s)
	echo "Installing Postgres cluster..."
	while [[ $(date -u +%s) -le $endtime ]] && kubectl get pods -l application=spilo -L spilo-role -n $backup_namespace  -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False
        do
	  i=$(( (i+1) %4 ))
          printf "\r %s" "${spin:$i:1}"
          sleep .1
        done
	if kubectl get pods -l application=spilo -L spilo-role -n $backup_namespace  -o  jsonpath="{.items[*].status.conditions[*].status}" | grep -q False;then
          echo "Postgress cluster installation failed"
          exit 1
        fi
	echo -e "You can now access the web interface of postgress operator by port forwarding the UI pod (mind the label selector) and enter localhost:8081 in your browser:\nkubectl port-forward svc/postgres-operator-ui 8081:80 -n $backup_namespace"
	#yq d -i backupplan.yaml spec.backupPlanComponents
	yq eval -i 'del(.spec.backupPlanComponents)' backupplan.yaml 2>/dev/null
        yq eval -i '.spec.backupPlanComponents.operators[0].operatorId="acid-minimal-cluster"' backupplan.yaml 2>/dev/null
	yq eval -i '.spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.group="acid.zalan.do" | .spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.group style="double"' backupplan.yaml 2>/dev/null
	yq eval -i '.spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.version="v1" | .spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.version style="double"' backupplan.yaml 2>/dev/null
	yq eval -i '.spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.kind="postgresql" | .spec.backupPlanComponents.operators[0].customResources[0].groupVersionKind.kind style="double"' backupplan.yaml 2>/dev/null
	yq eval -i '.spec.backupPlanComponents.operators[0].customResources[0].objects[0]="acid-minimal-cluster"' backupplan.yaml 2>/dev/null
        yq eval -i '.spec.backupPlanComponents.operators[0].operatorResourceSelector[0].matchLabels.name="postgres-operator"' backupplan.yaml 2>/dev/null
        yq eval -i '.spec.backupPlanComponents.operators[0].applicationResourceSelector[0].matchLabels.application="spilo"' backupplan.yaml 2>/dev/null
	;;
      4)
	if helm list -n $backup_namespace | grep -q -w mongotest
        then
          echo "Application exists"
          if ! [[ $if_resource_exists_still_proceed ]]
          then
            exit 1
          fi
        else
	  helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>/dev/null
          helm repo update >/dev/null 2>/dev/null
          helm install mongotest bitnami/mongodb -n $backup_namespace
	  echo "Installing App..."
	  runtime="15 minute"
          spin='-\|/'
          i=0
          endtime=$(date -ud "$runtime" +%s)
	  while [[ $(date -u +%s) -le $endtime ]] && kubectl get pod -l app.kubernetes.io/name=mongodb -n $backup_namespace -o  jsonpath="{.items[*].status.conditions[*].stat}" | grep -w False
          do
            i=$(( (i+1) %4 ))
            printf "\r %s" "${spin:$i:1}"
            sleep .1
          done
	  if kubectl get pod -l app.kubernetes.io/name=mongodb -n $backup_namespace -o  jsonpath="{.items[*].status.conditions[*].stat}" | grep -q False;then
            echo "Mongodb installation failed"
            exit 1
          fi
          yq eval -i 'del(.spec.backupPlanComponents)' backupplan.yaml 2>/dev/null
	  yq eval -i '.spec.backupPlanComponents.helmReleases[0]="mongotest"' backupplan.yaml 2>/dev/null
	fi
	;;
      *)
    	echo "Wrong choice"
        ;;
  esac
   echo "Requested application is installed successfully"
   #check if backupplan with same name already exists
   if [[ $(kubectl get backupplan $bk_plan_name  -n  $backup_namespace 2>/dev/null) ]];
      then
        echo "Backupplan with same name already exists"
        if ! [[ $if_resource_exists_still_proceed ]]
        then
          exit 1
        fi
   else
     #Applying backupplan manifest
     yq eval -i '.metadata.name="'$bk_plan_name'"' backupplan.yaml 2>/dev/null
     yq eval -i '.metadata.namespace="'$backup_namespace'"' backupplan.yaml 2>/dev/null
     yq eval -i '.spec.backupNamespace="'$backup_namespace'"' backupplan.yaml 2>/dev/null
     yq eval -i '.spec.backupConfig.target.name="'"$target_name"'"' backupplan.yaml 2>/dev/null
     yq eval -i '.spec.backupConfig.target.namespace="'"$target_namespace"'"' backupplan.yaml 2>/dev/null
     echo "Creating backupplan..."
     kubectl apply -f policy.yaml -n $backup_namespace 
     kubectl apply -f backupplan.yaml -n $backup_namespace
     cmd="kubectl get backupplan $bk_plan_name  -n  $backup_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -e Available -e Unavailable"
     wait_install "10 minute" "$cmd"
     if ! kubectl get backupplan $bk_plan_name  -n  $backup_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -q Available; then
       echo "Backupplan creation failed"
       exit 1
     else
       echo "Backupplan is in Available state"
     fi

   fi
   if [[ $(kubectl get backup $backup_name  -n  $backup_namespace 2>/dev/null) ]];
      then
        echo "Backup with same name already exists"
        if ! [[ $if_resource_exists_still_proceed ]]
        then
          exit 1
        fi
   else
     #Applying backup manifest
     yq eval -i '.metadata.name="'$backup_name'"' backup.yaml 2>/dev/null
     yq eval -i '.metadata.namespace="'$backup_namespace'"' backup.yaml 2>/dev/null
     yq eval -i '.spec.backupPlan.name="'$bk_plan_name'"' backup.yaml 2>/dev/null
     yq eval -i '.spec.backupPlan.namespace="'$backup_namespace'"' backup.yaml 2>/dev/null
     echo "Starting backup..."
     kubectl apply -f backup.yaml -n $backup_namespace
     cmd="kubectl get backup $backup_name -n  $backup_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -e Available -e Failed"
     wait_install "60 minute" "$cmd"
     if ! kubectl get backup $backup_name -n $backup_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -w Available; then
       echo "Backup Failed"
       exit 1
     else
       echo "Backup is Available Now"
     fi
   fi
   if  [[ -z ${input_config} ]];then
     read -r -p "whether restore test should also be done?y/n: " restore
   fi
   if [[ ${restore} == "Y" ]] || [[ ${restore} == "y" ]] || [[ ${restore} == "True" ]]
   then
     if  [[ -z ${input_config} ]];then
       read -r -p "Restore Namepsace(trilio-test-rest): " restore_namespace
       read -r -p "Restore name(trilio-test-restore): " restore_name
     fi
     if [[ -z "$restore_namespace" ]]; then
	restore_namespace="trilio-test-rest"
     fi
     kubectl create ns $restore_namespace 2>/dev/null
     if [[ -z "$restore_name" ]]; then
	restore_name="trilio-test-restore"
     fi
     if [[ $(kubectl get restore $restore_name  -n  $restore_namespace 2>/dev/null) ]];
      then
        echo "Restore with same name already exists"
        if ! [[ $if_resource_exists_still_proceed ]]
        then
          exit 1
        fi
     else
       yq eval -i '.metadata.name="'$restore_name'"' restore.yaml 2>/dev/null
       yq eval -i '.metadata.namespace="'$restore_namespace'"' restore.yaml 2>/dev/null
       yq eval -i '.spec.restoreNamespace="'$restore_namespace'"' restore.yaml 2>/dev/null
       yq eval -i '.spec.source.target.name="'"$target_name"'"' restore.yaml 2>/dev/null
       yq eval -i '.spec.source.target.namespace="'"$target_namespace"'"' restore.yaml 2>/dev/null
       yq eval -i '.spec.source.backup.name="'$backup_name'"' restore.yaml 2>/dev/null
       yq eval -i '.spec.source.backup.namespace="'$backup_namespace'"' restore.yaml 2>/dev/null
       echo "Starting restore..."
       kubectl apply -f restore.yaml -n $restore_namespace
       cmd="kubectl get restore $restore_name -n $restore_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -e Completed -e Failed"
       wait_install "60 minute" "$cmd"
       if ! kubectl get restore $restore_name -n $restore_namespace -o 'jsonpath={.status.status}' 2>/dev/null | grep -w 'Completed'; then
         echo "Restore Failed"
         exit 1
       else
         echo "Restore is Completed"
       fi
     fi
   fi
}




print_usage(){
  echo "
--------------------------------------------------------------
tvk-oneclick - Installs, Configures UI, Create sample backup/restore test
Usage:
kubectl tvk-oneclick [options] [arguments]
Options:
        -h, --help                show brief help
        -n, --noninteractive      run script in non-interactive mode.for this you need to provide config file
        -i, --install_tvk         Installs TVK and it's free trial license.
        -c, --configure_ui        Configures TVK UI
        -t, --target              Created Target for backup and restore jobs
        -s, --sample_test         Create sample backup and restore jobs
	-p, --preflight           Checks if all the pre-requisites are satisfied
-----------------------------------------------------------------------
"
}

main()
{
  log_file="logs.txt"
  exec &> >(tee -a "$log_file")
  for i in "$@"; do
    #key="$1"
    case $i in
      -h|--help)
        print_usage
        exit 0
        ;;
      -n|--noninteractive)
        export Non_interact=True
        echo "Flag set to run cleanup in non-interactive mode"
        echo
        ;;
      -i|--install_tvk)
	export TVK_INSTALL=True
	#echo "Flag set to install TVK product"
	shift
	echo
	;;
      -c|--configure_ui)
	export CONFIGURE_UI=True
	#echo "flag set to configure ui"
	echo
	;;
      -t|--target)
	export TARGET=True
        #echo "flag set to create backup target"
	shift
	echo
	;;
      -s|--sample_test)
        export SAMPLE_TEST=True
	#echo "flag set to test sample  backup and restore of application "
	echo
	;;
      -p|--preflight)
	export PREFLIGHT=True
	echo
	;;
      *)
      echo "Incorrect option, check usage below..."
      echo
      print_usage
      exit 1
      ;;
     esac
     shift
  done
  export input_config=""
  if [ ${Non_interact} ]
  then
    read -r -p "Please enter path for config file: " input_config
    # shellcheck source=/dev/null
    . $input_config
    export input_config=$input_config
  fi
  if [[ ${PREFLIGHT} == 'True'  ]]
  then
    preflight_checks
  fi
  if [[ ${TVK_INSTALL} == 'True' ]]
  then  
    install_tvk
  fi
  if [[ ${CONFIGURE_UI} == 'True' ]]
  then
    configure_ui
  fi
  if [[ ${TARGET} == 'True' ]]
  then
    create_target   
  fi
  if [[ ${SAMPLE_TEST} == 'True' ]]
  then
    sample_test
  fi
    
}
main "$@"
